from typing import List

import numpy as np

from pymc_experimental.statespace.utils.constants import (
    ALL_STATE_AUX_DIM,
    ALL_STATE_DIM,
    OBS_STATE_AUX_DIM,
    OBS_STATE_DIM,
    SHOCK_AUX_DIM,
    SHOCK_DIM,
)


def make_default_coords(ss_mod):
    coords = {
        ALL_STATE_DIM: ss_mod.state_names,
        ALL_STATE_AUX_DIM: ss_mod.state_names,
        OBS_STATE_DIM: ss_mod.observed_states,
        OBS_STATE_AUX_DIM: ss_mod.observed_states,
        SHOCK_DIM: ss_mod.shock_names,
        SHOCK_AUX_DIM: ss_mod.shock_names,
    }

    return coords


def cleanup_states(states: List[str]) -> List[str]:
    """
    Remove meaningless symbols from state names

    Parameters
    ----------
    states, list of str
        State names generated by make_harvey_state_names

    Returns
    -------
    states, list of str
        State names for the Harvey statespace representation, with meaningless terms removed

    The state names generated by make_harvey_state_names includes some "meaningless" terms. For example, lags are
    indicated with L{i}.state. This includes L0.state, which is correctly just "state".

    In addition, sequential applications of the difference operator are denoted Dk^i, where k is the length of the
    difference, and i is the number of repeated applications. Dk^1 is thus just Dk.
    """

    out = []
    for state in states:
        state = state.replace("^1", "")
        state = state.replace("L0", "")
        out.append(state)
    return out


def make_harvey_state_names(p, d, q, P, D, Q, S) -> List[str]:
    """
    Generate informative names for the SARIMA states in the Harvey representation

    Parameters
    ----------
    p, int
        AR order
    d, int
        Number of ARIMA differences
    q, int
        MA order
    P, int
        Seasonal AR order
    D, int
        Number of seasonal differences
    Q, int
        Seasonal MA order
    S, int
        Seasonal length

    Returns
    -------
    state_names, list of str
        List of state names

    The Harvey state is not particularly interpretable, but it's also not totally opaque. This helper function makes
    a list of state names that can help users understand what they are getting back from the statespace. In particular,
    it is helpful to know how differences and seasonal differences are incorporated into the model
    """
    n_diffs = S * D + d
    k_lags = max(p + P * S, q + Q * S + 1)
    k_states = k_lags + n_diffs

    # First state is always data
    states = ["data"]

    # Next we add the ARIMA differences
    states.extend([f"D1^{(i + 1)}.data" for i in range(d)[:-1]])

    # This next line handles two cases. If d > 0, we need to do cycles of the "base state" for the seasonal
    # terms. If d == 0, we can start adding the seasonal lags.

    # No matter what, we're going to need a total of S * max(P, Q+1) seasonal lags, so we add the first S
    # here if d = 0. These will also be the first rotation of the seasonal differences corresponding to D=1
    has_diff = (d + D) > 0
    has_single_diff = ((d == 0) & (D != 0)) | ((d != 0) & (D == 0))
    has_both_diff = (d > 0) & (D > 0)

    prefix = f"D1^{d}" if d > 0 else ""
    lag_adj = 1 - int(d > 0)
    season_adj = 1 - has_both_diff
    states.extend([f"{prefix}L{i + lag_adj}.data" for i in range(S - season_adj)])

    suffix = "_star" if has_diff else ""

    # Handle seasonal differences. This involves cyling the base state and adding an additonal Î”S every
    # S seasons
    states.extend([f"D{S}^{(d + 1)}{prefix}L{i}.data" for d in range(D - 1) for i in range(S)])

    if has_diff:
        states.append(f"data{suffix}")
    # Next we need to add the actual "computation" states.

    # If d = 0 and D = 0, these are just lags of the data, equal to max(p + P * S, q + Q * S + 1). We already
    # added S lags above, so shift the lag index to restart the count from there
    adj = max(1, S * (1 - int(has_diff)) + int(has_diff))

    # We also need to figure out how many more lags to add. There are two cases. If we don't have any differences,
    # the seasonal "rolling" is handled by this block, so there are more states. If we do have differences, the
    # rolling is handled above, so we only need to handle ARIMA dynamics of x_star, which is max(p, q+1) states

    if has_diff:
        # x_star itself counts and was already handled, so subtract 1
        n_more_lags = max(p + P * S, q + Q * S + 1) - has_single_diff - (1 - season_adj)
    else:
        # subtract seasonal lags already added, as well as x_star
        n_more_lags = max(p + P * S, q + Q * S + 1) - max(0, S - 1) - 1

    if suffix == "_star" or S == 0:
        states.extend([f"state{suffix}_{adj + i}" for i in range(n_more_lags)])
    else:
        states.extend([f"L{adj + i}.state{suffix}" for i in range(n_more_lags)])
    states = cleanup_states(states)

    return states


def make_seasonal_T(p: int, d: int, q: int, P: int, D: int, Q: int, S: int) -> np.ndarray:
    r"""
    Make the transition matrix for a SARIMA model

    Parameters
    ----------
    p, int
        AR order
    d, int
        Number of ARIMA differences
    q, int
        MA order
    P, int
        Seasonal AR order
    D, int
        Number of seasonal differences
    Q, int
        Seasonal MA order
    S, int
        Seasonal length

    Returns
    -------
    T, ndarray
        The transition matrix associated with a SARIMA model of order (p,d,q)x(P,D,Q,S)

    Notes
    -----
    The transition matrix for the SARIMA model has a bunch of structure in it, especially when differences are included
    in the statespace model. This function will always assume the state space matrix is in the Harvey representation.

    Given this representation, the matrix can be divided into a bottom part and a top part. The top part has (S * D) + d
    rows, and is associated with the differencing operations. The bottom part has max(P*S+p, Q*S+q+1) rows, and is
    responsible for the actual time series dynamics.

    The bottom part of the matrix is quite simple, it is just a shifted identity matrix (called a "companion matrix"),
    responsible for "rolling" the states, so that at each transition, the value for :math:`x_{t-3}` becomes the value
    for :math:`x_{t-2}`, and so on.

    The top part is quite complex. The goal of this part of the matrix is to transform the raw data state, :math:`x_t`,
    into a stationary state, :math:`x_t^\star`, via the application of differencing operations,
    :math:`\Delta x_t = x_t - x_{t-1}`. For ARIMA differences (the little ``d``), this is quite simple. Sequential
    differences are representated as an upper-triangular matrix of ones. To see this, consider an example where ``d=3``,
    so that:
     .. math::

        \begin{align}
            x_t^\star &= \Delta^3 x_t \\
             &= \Delta^2 (x_t - x_{t-1})
             &= \Delta (x_t - 2x_{t-1} + x_{t-2})
             &= x_t - x_{t-1} - 2x_{t-1} + 2x_{t-3} + x_{t-2} - x_{t-3}
             &= x_t - 3x_{t-1} + 3x_{t-3} - x_{t-3}
        \end{align}

    If you choose a state vector :math:`\begin{bmatrix}x_t & \Delta x_t & \Delta^2 x_t & x_t^\star \end{bmatrix}^T`,
    you will find that:

    .. math::
        \begin{bmatrix}x_t \\ \Delta x_t \\ \Delta^2 x_t \\ x_t^\star \end{bmatrix} =
            \begin{bmatrix} 1 & 1 & 1 & 1 \\
                            0 & 1 & 1 & 1 \\
                            0 & 0 & 1 & 1 \\
                            0 & 0 & 0 & 1
            \end{bmatrix}
            \begin{bmatrix} x_{t-1} \\ \Delta x_{t-1} \\ \Delta^2 x_{t-1} \\ x_{t-1}^\star \end{bmatrix}

    The upper-left corner has an upper-triangular matrix of shape ``(d,d)``, responsible for creating the ARIMA differences.


    """
    n_diffs = S * D + d
    k_lags = max(p + P * S, q + Q * S + 1)
    k_states = k_lags + n_diffs

    # Top Part
    # ARIMA differences
    T = np.zeros((k_states, k_states))
    diff_idx = np.triu_indices(d)
    T[diff_idx] = 1

    # First block of seasonal differences
    sum_row_idx = np.arange(d + 1).repeat(D + 1)
    sum_col_idx = (S - 1) * np.arange(D + 1)[1:] + np.arange(D + 1)[:-1]
    sum_col_idx = d + np.tile(np.r_[sum_col_idx, sum_col_idx[-1] + 1], d + 1)

    # Higher order seasonal differences
    sum_row_idx = np.r_[
        sum_row_idx, np.concatenate([sum_row_idx[-(D - i) :] + S * i for i in range(D)])
    ]
    sum_col_idx = np.r_[
        sum_col_idx, np.concatenate([sum_col_idx[-(D - i) :] for i in range(D)] * D)
    ]

    T[sum_row_idx, sum_col_idx] = 1

    # "Rolling" indices for seasonal differences
    (row_roll_idx, col_roll_idx) = np.diag_indices(S * D)
    row_roll_idx = row_roll_idx + d + 1
    col_roll_idx = col_roll_idx + d

    # Rolling indices have a zero after every diagonal of length S-1
    T[row_roll_idx, col_roll_idx] = 1
    zero_idx = row_roll_idx[S - 1 :: S], col_roll_idx[S - 1 :: S]
    T[zero_idx] = 0

    # Bottom part
    # Rolling indices for the "compute" states, x_star
    star_roll_row, star_roll_col = np.diag_indices(k_lags - 1)
    star_roll_row = star_roll_row + n_diffs
    star_roll_col = star_roll_col + n_diffs + 1

    T[star_roll_row, star_roll_col] = 1

    return T
